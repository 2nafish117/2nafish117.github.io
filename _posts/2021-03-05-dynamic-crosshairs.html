---
layout: post
title: "Dynamic crosshairs with shaders"
subtitle: "todo subtitle"
date: 2021-03-05 12:00:00 +0530
background: '/img/godot-code-bg.jpg'
---

<!-- see below link for code formatting shit -->
<!-- https://therealweblog.blogspot.com/2019/05/how-to-format-code-snippets-in-blogger.html -->
<!-- https://github.com/highlightjs/highlight.js/blob/master/SUPPORTED_LANGUAGES.md -->
<!-- this is all code formatting shit -->
<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/atom-one-dark-reasonable.min.css' rel='stylesheet'/>
<script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js'></script>
<script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/r.min.js'></script>
<script>hljs.initHighlightingOnLoad();</script>
<!-- glslViewer -->
<script type="text/javascript" src="https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js"></script>

<!-- see this for charecter encodings in html -->
<!-- https://www.freeformatter.com/html-entities.html -->

<p>
	You ever feel like you want your crosshair.png to be dynamic and show some movement?
	Yeah? you can do it with some simple shaders.
</p>
<canvas class="glslCanvas" data-fragment-url="shader.frag" width="500" height="500"></canvas>
<p>
	I'll be using plain old glsl in my code snippets here, feel free to port it to any other shading language out there.
	If you want to try it out right in your browser check out the <a href="http://editor.thebookofshaders.com/">book of shaders editor</a>.
	<a href="http://thebookofshaders.com/">The Book of Shaders</a> is also an excellent resource if you want to learn more about shaders.
</p>

<h2 class="section-heading">The Idea</h2>
<p>
	The basic idea of creating shapes in a fragment shader is to make a mask using shader functions that fills the crosshair shape you want, 
	and then animate this mask using a time uniform or another uniform. 
</p>
<p>
	You can create multiple simple masks and then put them together to make composite masks.
	You can sometimes get away with texture masks instead of creating them by shader code. 
	But the beauty of shader masks are that they can be scaled arbitrarily without loss in quality. 
	Finally this mask can be multiplied with a color to get your final crosshair.
</p>

<h2 class="section-heading">The Code</h2>
<p>
	Here are a few snippets of simple masks that can be used to make more complex masks. 
	Each of them is run for every pixel on the crosshair and returns some value in the range <code>[0.0, 1.0]</code>.
	A value of 1.0 implies the pixel is colored, 0.0 means the pixel is transparent. (It's a mask bruh)
</p>

<pre><code class="glsl">&#47;&#47; Simple Masks
#define SMOOTH_AMOUNT 0.005 &#47;&#47; Smooth the edges of the masks

float mask_circle(vec2 st, vec2 center, float radius) {
	return 1.0 - smoothstep(radius - SMOOTH_AMOUNT, radius + SMOOTH_AMOUNT, length(st - center));
}

float mask_ellipse(vec2 st, vec2 center, float r1, float r2) {
	st -= center;
	float d = st.x * st.x / (r1 * r1) + st.y * st.y / (r2 * r2);
	return 1.0 - smoothstep(1.0 - 10.0 * SMOOTH_AMOUNT, 1.0 + 10.0 * SMOOTH_AMOUNT, d);
}

float mask_ring(vec2 st, vec2 center, float inner, float outer) {
	return (1.0 - mask_circle(st, center, inner)) * mask_circle(st, center, outer);
}

float mask_plus(vec2 st, vec2 center, float width) {
	return 1.0 - min(
		smoothstep(width - SMOOTH_AMOUNT, width + SMOOTH_AMOUNT, abs(st.x)), 
		smoothstep(width - SMOOTH_AMOUNT, width + SMOOTH_AMOUNT, abs(st.y))
	);
}

float mask_square(vec2 st, vec2 center, float width) {
	return 1.0 - max(
		smoothstep(width - SMOOTH_AMOUNT, width + SMOOTH_AMOUNT, abs(st.x)), 
		smoothstep(width - SMOOTH_AMOUNT, width + SMOOTH_AMOUNT, abs(st.y))
	);
}
</code></pre>

<p>
	You can see the extensive use of simple shader functions like 
	<code>smoothstep</code>, <code>min</code>, <code>max</code>, and <code>abs</code>.
	The <code>mask_plus</code> works by doing a union of a vertical and horizontal strip to form a plus.
	The <code>mask_square</code> works in the exact opposite way, it uses the intersection of the vertical and horizontal strip to form a square.
	The <code>mask_ring</code> works by using two <code>mask_circle</code> calls and cutting out the inner circle from the outer circle.
	You can see now how you can combine multiple masks, this can be generalised similar to set theory.
</p>

<pre><code class="cpp">&#47;&#47; Mask Arithmetic?
mask = 1.0 - mask   &#47;&#47; inverse of mask

&#47;&#47; union and intersection using max, min
mask = max(mask1, mask2) &#47;&#47; mask1 union mask2
mask = min(mask1, mask2) &#47;&#47; mask1 intersection mask2

&#47;&#47; union and intersection using addition, multiplication
mask = clamp(0.0, 1.0, mask1 + mask2) &#47;&#47; mask1 union mask2
mask = mask1 * mask2 				&#47;&#47; mask1 intersection mask2

&#47;&#47; here intersection can be any of the methods shown above
mask = mask1 intersection (1.0 - mask2) &#47;&#47; mask1 set-subtract mask2
</code></pre>

<p>
	Who knows, maybe more of the boolean algebra works on these? Maybe de-morgans laws. 
	An idea for another post perhaps.
</p>

<!-- <p>Never in all their history have men been able truly to conceive of the world as one: a single sphere, a globe, having the qualities of a globe, a round earth in which all the directions eventually meet, in which there is no center because every point, or none, is center — an equal earth which all men occupy as equals. The airman's earth, if free men make it, will be truly round: a globe in practice, not in theory.</p>
<h2 class="section-heading">The Final Frontier</h2>
<blockquote class="blockquote">The dreams of yesterday are the hopes of today and the reality of tomorrow. Science has not yet mastered prophecy. We predict too much for the next year and yet far too little for the next ten.</blockquote>
<img class="img-fluid" src="https://source.unsplash.com/Mn9Fa_wQH-M/800x450" alt="Demo Image">
<span class="caption text-muted">To go places and do things that have never been done before – that’s what living is all about.</span> -->
